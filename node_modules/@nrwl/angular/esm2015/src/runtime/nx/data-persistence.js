import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Actions, ofType } from '@ngrx/effects';
import { ROUTER_NAVIGATION } from '@ngrx/router-store';
import { Action, Store, ActionCreator } from '@ngrx/store';
import { Observable, of } from 'rxjs';
import { catchError, concatMap, filter, groupBy, map, mergeMap, switchMap, withLatestFrom } from 'rxjs/operators';
export function pessimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
export function optimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
    };
}
export function fetch(opts) {
    return (source) => {
        if (opts.id) {
            const groupedFetches = source.pipe(mapActionAndState(), groupBy(([action, store]) => {
                return opts.id(action, store);
            }));
            return groupedFetches.pipe(mergeMap(pairs => pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))));
        }
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
export function navigation(component, opts) {
    return (source) => {
        const nav = source.pipe(mapActionAndState(), filter(([action, state]) => isStateSnapshot(action)), map(([action, state]) => {
            if (!isStateSnapshot(action)) {
                // Because of the above filter we'll never get here,
                // but this properly type narrows `action`
                return;
            }
            return [
                findSnapshot(component, action.payload.routerState.root),
                state
            ];
        }), filter(([snapshot, state]) => !!snapshot));
        return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
function isStateSnapshot(action) {
    return action.type === ROUTER_NAVIGATION;
}
function runWithErrorHandling(run, onError) {
    return ([action, state]) => {
        try {
            const r = wrapIntoObservable(run(action, state));
            return r.pipe(catchError(e => wrapIntoObservable(onError(action, e))));
        }
        catch (e) {
            return wrapIntoObservable(onError(action, e));
        }
    };
}
/**
 * @whatItDoes maps Observable<Action | [Action, State]> to
 * Observable<[Action, State]>
 */
function mapActionAndState() {
    return (source) => {
        return source.pipe(map(value => {
            const [action, store] = normalizeActionAndState(value);
            return [action, store];
        }));
    };
}
/**
 * @whatItDoes Normalizes either a bare action or an array of action and state
 * into an array of action and state (or undefined)
 */
function normalizeActionAndState(args) {
    let action, state;
    if (args instanceof Array) {
        [action, state] = args;
    }
    else {
        action = args;
    }
    return [action, state];
}
/**
 * @whatItDoes Provides convenience methods for implementing common operations of persisting data.
 */
let DataPersistence = class DataPersistence {
    constructor(store, actions) {
        this.store = store;
        this.actions = actions;
    }
    /**
     *
     * @whatItDoes Handles pessimistic updates (updating the server first).
     *
     * Update the server implemented naively suffers from race conditions and poor error handling.
     *
     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run(a, state) {
     *       // update the backend first, and then dispatch an action that will
     *       // update the client side
     *       return this.backend(state.user, a.payload).map(updated => ({
     *         type: 'TODO_UPDATED',
     *         payload: updated
     *       }));
     *     },
     *
     *     onError(a, e: any) {
     *       // we don't need to undo the changes on the client side.
     *       // we can dispatch an error, or simply log the error here and return `null`
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    pessimisticUpdate(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), pessimisticUpdate(opts));
    }
    /**
     *
     * @whatItDoes Handles optimistic updates (updating the client first).
     *
     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
     * the developer already updated the state locally, so the developer must provide an undo action.
     *
     * The error handling must be done in the callback, or by means of the undo action.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload);
     *     },
     *
     *     undoAction: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return ({
     *         type: 'UNDO_UPDATE_TODO',
     *         payload: a
     *       });
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    optimisticUpdate(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), optimisticUpdate(opts));
    }
    /**
     *
     * @whatItDoes Handles data fetching.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODOS',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * This is correct, but because it set the concurrency to 1, it may not be performant.
     *
     * To fix that, you can provide the `id` function, like this:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
     *     id: (a, state) => {
     *       return a.payload.id;
     *     }
     *
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODO',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
     *
     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
     * it will only run the last one.
     */
    fetch(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), fetch(opts));
    }
    /**
     * @whatItDoes Handles data fetching as part of router navigation.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `navigation` addresses these problems.
     *
     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
     * the last request.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.navigation(TodoComponent, {
     *     run: (a, state) => {
     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
     *         type: 'TODO_LOADED',
     *         payload: todo
     *       }));
     *     },
     *     onError: (a, e: any) => {
     *       // we can log and error here and return null
     *       // we can also navigate back
     *       return null;
     *     }
     *   });
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     */
    navigation(component, opts) {
        return this.actions.pipe(withLatestFrom(this.store), navigation(component, opts));
    }
};
DataPersistence.ctorParameters = () => [
    { type: Store },
    { type: Actions }
];
DataPersistence = __decorate([
    Injectable()
], DataPersistence);
export { DataPersistence };
function findSnapshot(component, s) {
    if (s.routeConfig && s.routeConfig.component === component) {
        return s;
    }
    for (const c of s.children) {
        const ss = findSnapshot(component, c);
        if (ss) {
            return ss;
        }
    }
    return null;
}
function wrapIntoObservable(obj) {
    if (!!obj && obj instanceof Observable) {
        return obj;
    }
    else if (!obj) {
        return of();
    }
    else {
        return of(obj);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wZXJzaXN0ZW5jZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BucndsL2FuZ3VsYXIvIiwic291cmNlcyI6WyJzcmMvcnVudGltZS9ueC9kYXRhLXBlcnNpc3RlbmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFRLE1BQU0sZUFBZSxDQUFDO0FBRWpELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxpQkFBaUIsRUFBMEIsTUFBTSxvQkFBb0IsQ0FBQztBQUMvRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxhQUFhLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDM0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUNMLFVBQVUsRUFDVixTQUFTLEVBQ1QsTUFBTSxFQUNOLE9BQU8sRUFDUCxHQUFHLEVBQ0gsUUFBUSxFQUNSLFNBQVMsRUFDVCxjQUFjLEVBQ2YsTUFBTSxnQkFBZ0IsQ0FBQztBQXFDeEIsTUFBTSxVQUFVLGlCQUFpQixDQUMvQixJQUFpQztJQUVqQyxPQUFPLENBQUMsTUFBK0IsRUFBc0IsRUFBRTtRQUM3RCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQ2hCLGlCQUFpQixFQUFFLEVBQ25CLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUN4RCxDQUFDO0lBQ0osQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FDOUIsSUFBZ0M7SUFFaEMsT0FBTyxDQUFDLE1BQStCLEVBQXNCLEVBQUU7UUFDN0QsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUNoQixpQkFBaUIsRUFBRSxFQUNuQixTQUFTLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENB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QUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxTQUFTLEtBQUssU0FBUyxFQUFFO1FBQzFELE9BQU8sQ0FBQyxDQUFDO0tBQ1Y7SUFDRCxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUU7UUFDMUIsTUFBTSxFQUFFLEdBQUcsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFJLEVBQUUsRUFBRTtZQUNOLE9BQU8sRUFBRSxDQUFDO1NBQ1g7S0FDRjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVELFNBQVMsa0JBQWtCLENBQUksR0FBNkI7SUFDMUQsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsWUFBWSxVQUFVLEVBQUU7UUFDdEMsT0FBTyxHQUFHLENBQUM7S0FDWjtTQUFNLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDZixPQUFPLEVBQUUsRUFBRSxDQUFDO0tBQ2I7U0FBTTtRQUNMLE9BQU8sRUFBRSxDQUFDLEdBQVEsQ0FBQyxDQUFDO0tBQ3JCO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIFJvdXRlclN0YXRlU25hcHNob3QgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQWN0aW9ucywgb2ZUeXBlIH0gZnJvbSAnQG5ncngvZWZmZWN0cyc7XG5pbXBvcnQgeyBST1VURVJfTkFWSUdBVElPTiwgUm91dGVyTmF2aWdhdGlvbkFjdGlvbiB9IGZyb20gJ0BuZ3J4L3JvdXRlci1zdG9yZSc7XG5pbXBvcnQgeyBBY3Rpb24sIFN0b3JlLCBBY3Rpb25DcmVhdG9yIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGNvbmNhdE1hcCxcbiAgZmlsdGVyLFxuICBncm91cEJ5LFxuICBtYXAsXG4gIG1lcmdlTWFwLFxuICBzd2l0Y2hNYXAsXG4gIHdpdGhMYXRlc3RGcm9tXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZS5wZXNzaW1pc3RpY1VwZGF0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGVzc2ltaXN0aWNVcGRhdGVPcHRzPFQsIEE+IHtcbiAgcnVuKGE6IEEsIHN0YXRlPzogVCk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIG9uRXJyb3IoYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZS5wZXNzaW1pc3RpY1VwZGF0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT4ge1xuICBydW4oYTogQSwgc3RhdGU/OiBUKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgdW5kb0FjdGlvbihhOiBBLCBlOiBhbnkpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb247XG59XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UuZmV0Y2h9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoT3B0czxULCBBPiB7XG4gIGlkPyhhOiBBLCBzdGF0ZT86IFQpOiBhbnk7XG4gIHJ1bihhOiBBLCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICBvbkVycm9yPyhhOiBBLCBlOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4gfCBhbnk7XG59XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UubmF2aWdhdGlvbn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFuZGxlTmF2aWdhdGlvbk9wdHM8VD4ge1xuICBydW4oYTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgc3RhdGU/OiBUKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgb25FcnJvcj8oYTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuXG5leHBvcnQgdHlwZSBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZTxULCBBPiA9IEEgfCBbQSwgVF07XG5leHBvcnQgdHlwZSBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPiA9IE9ic2VydmFibGU8QWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4+O1xuXG5leHBvcnQgZnVuY3Rpb24gcGVzc2ltaXN0aWNVcGRhdGU8VCwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIG9wdHM6IFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPlxuKSB7XG4gIHJldHVybiAoc291cmNlOiBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPik6IE9ic2VydmFibGU8QWN0aW9uPiA9PiB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGNvbmNhdE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSlcbiAgICApO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3B0aW1pc3RpY1VwZGF0ZTxULCBBIGV4dGVuZHMgQWN0aW9uPihcbiAgb3B0czogT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBjb25jYXRNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMudW5kb0FjdGlvbikpXG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoPFQsIEEgZXh0ZW5kcyBBY3Rpb24+KG9wdHM6IEZldGNoT3B0czxULCBBPikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIGlmIChvcHRzLmlkKSB7XG4gICAgICBjb25zdCBncm91cGVkRmV0Y2hlcyA9IHNvdXJjZS5waXBlKFxuICAgICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgICBncm91cEJ5KChbYWN0aW9uLCBzdG9yZV0pID0+IHtcbiAgICAgICAgICByZXR1cm4gb3B0cy5pZChhY3Rpb24sIHN0b3JlKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBncm91cGVkRmV0Y2hlcy5waXBlKFxuICAgICAgICBtZXJnZU1hcChwYWlycyA9PlxuICAgICAgICAgIHBhaXJzLnBpcGUoc3dpdGNoTWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKVxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0aW9uPFQsIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgb3B0czogSGFuZGxlTmF2aWdhdGlvbk9wdHM8VD5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pID0+IHtcbiAgICBjb25zdCBuYXYgPSBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBmaWx0ZXIoKFthY3Rpb24sIHN0YXRlXSkgPT4gaXNTdGF0ZVNuYXBzaG90KGFjdGlvbikpLFxuICAgICAgbWFwKChbYWN0aW9uLCBzdGF0ZV0pID0+IHtcbiAgICAgICAgaWYgKCFpc1N0YXRlU25hcHNob3QoYWN0aW9uKSkge1xuICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhlIGFib3ZlIGZpbHRlciB3ZSdsbCBuZXZlciBnZXQgaGVyZSxcbiAgICAgICAgICAvLyBidXQgdGhpcyBwcm9wZXJseSB0eXBlIG5hcnJvd3MgYGFjdGlvbmBcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGZpbmRTbmFwc2hvdChjb21wb25lbnQsIGFjdGlvbi5wYXlsb2FkLnJvdXRlclN0YXRlLnJvb3QpLFxuICAgICAgICAgIHN0YXRlXG4gICAgICAgIF0gYXMgW0FjdGl2YXRlZFJvdXRlU25hcHNob3QsIFRdO1xuICAgICAgfSksXG4gICAgICBmaWx0ZXIoKFtzbmFwc2hvdCwgc3RhdGVdKSA9PiAhIXNuYXBzaG90KVxuICAgICk7XG5cbiAgICByZXR1cm4gbmF2LnBpcGUoc3dpdGNoTWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGVTbmFwc2hvdChcbiAgYWN0aW9uOiBhbnlcbik6IGFjdGlvbiBpcyBSb3V0ZXJOYXZpZ2F0aW9uQWN0aW9uPFJvdXRlclN0YXRlU25hcHNob3Q+IHtcbiAgcmV0dXJuIGFjdGlvbi50eXBlID09PSBST1VURVJfTkFWSUdBVElPTjtcbn1cblxuZnVuY3Rpb24gcnVuV2l0aEVycm9ySGFuZGxpbmc8VCwgQSwgUj4oXG4gIHJ1bjogKGE6IEEsIHN0YXRlPzogVCkgPT4gT2JzZXJ2YWJsZTxSPiB8IFIgfCB2b2lkLFxuICBvbkVycm9yOiBhbnlcbikge1xuICByZXR1cm4gKFthY3Rpb24sIHN0YXRlXTogW0EsIFRdKTogT2JzZXJ2YWJsZTxSPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHIgPSB3cmFwSW50b09ic2VydmFibGUocnVuKGFjdGlvbiwgc3RhdGUpKTtcbiAgICAgIHJldHVybiByLnBpcGUoY2F0Y2hFcnJvcihlID0+IHdyYXBJbnRvT2JzZXJ2YWJsZShvbkVycm9yKGFjdGlvbiwgZSkpKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHdyYXBJbnRvT2JzZXJ2YWJsZShvbkVycm9yKGFjdGlvbiwgZSkpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBtYXBzIE9ic2VydmFibGU8QWN0aW9uIHwgW0FjdGlvbiwgU3RhdGVdPiB0b1xuICogT2JzZXJ2YWJsZTxbQWN0aW9uLCBTdGF0ZV0+XG4gKi9cbmZ1bmN0aW9uIG1hcEFjdGlvbkFuZFN0YXRlPFQsIEE+KCkge1xuICByZXR1cm4gKHNvdXJjZTogT2JzZXJ2YWJsZTxBY3Rpb25PckFjdGlvbldpdGhTdGF0ZTxULCBBPj4pID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXAodmFsdWUgPT4ge1xuICAgICAgICBjb25zdCBbYWN0aW9uLCBzdG9yZV0gPSBub3JtYWxpemVBY3Rpb25BbmRTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBbYWN0aW9uLCBzdG9yZV0gYXMgW0EsIFRdO1xuICAgICAgfSlcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEB3aGF0SXREb2VzIE5vcm1hbGl6ZXMgZWl0aGVyIGEgYmFyZSBhY3Rpb24gb3IgYW4gYXJyYXkgb2YgYWN0aW9uIGFuZCBzdGF0ZVxuICogaW50byBhbiBhcnJheSBvZiBhY3Rpb24gYW5kIHN0YXRlIChvciB1bmRlZmluZWQpXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFjdGlvbkFuZFN0YXRlPFQsIEE+KFxuICBhcmdzOiBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZTxULCBBPlxuKTogW0EsIFRdIHtcbiAgbGV0IGFjdGlvbjogQSwgc3RhdGU6IFQ7XG5cbiAgaWYgKGFyZ3MgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIFthY3Rpb24sIHN0YXRlXSA9IGFyZ3M7XG4gIH0gZWxzZSB7XG4gICAgYWN0aW9uID0gYXJncztcbiAgfVxuXG4gIHJldHVybiBbYWN0aW9uLCBzdGF0ZV07XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgUHJvdmlkZXMgY29udmVuaWVuY2UgbWV0aG9kcyBmb3IgaW1wbGVtZW50aW5nIGNvbW1vbiBvcGVyYXRpb25zIG9mIHBlcnNpc3RpbmcgZGF0YS5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGFQZXJzaXN0ZW5jZTxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzdG9yZTogU3RvcmU8VD4sIHB1YmxpYyBhY3Rpb25zOiBBY3Rpb25zKSB7fVxuXG4gIC8qKlxuICAgKlxuICAgKiBAd2hhdEl0RG9lcyBIYW5kbGVzIHBlc3NpbWlzdGljIHVwZGF0ZXMgKHVwZGF0aW5nIHRoZSBzZXJ2ZXIgZmlyc3QpLlxuICAgKlxuICAgKiBVcGRhdGUgdGhlIHNlcnZlciBpbXBsZW1lbnRlZCBuYWl2ZWx5IHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gICAqXG4gICAqIGBwZXNzaW1pc3RpY1VwZGF0ZWAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLS1pdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICAgKiBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgdXBkYXRlVG9kbyA9IHRoaXMucy5wZXNzaW1pc3RpY1VwZGF0ZTxVcGRhdGVUb2RvPignVVBEQVRFX1RPRE8nLCB7XG4gICAqICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb24gYW5kIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzdG9yZVxuICAgKiAgICAgcnVuKGEsIHN0YXRlKSB7XG4gICAqICAgICAgIC8vIHVwZGF0ZSB0aGUgYmFja2VuZCBmaXJzdCwgYW5kIHRoZW4gZGlzcGF0Y2ggYW4gYWN0aW9uIHRoYXQgd2lsbFxuICAgKiAgICAgICAvLyB1cGRhdGUgdGhlIGNsaWVudCBzaWRlXG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKS5tYXAodXBkYXRlZCA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPX1VQREFURUQnLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZWRcbiAgICogICAgICAgfSkpO1xuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIG9uRXJyb3IoYSwgZTogYW55KSB7XG4gICAqICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gdW5kbyB0aGUgY2hhbmdlcyBvbiB0aGUgY2xpZW50IHNpZGUuXG4gICAqICAgICAgIC8vIHdlIGNhbiBkaXNwYXRjaCBhbiBlcnJvciwgb3Igc2ltcGx5IGxvZyB0aGUgZXJyb3IgaGVyZSBhbmQgcmV0dXJuIGBudWxsYFxuICAgKiAgICAgICByZXR1cm4gbnVsbDtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRvbid0IHJldHVybiBhIG5ldyBhY3Rpb24gZnJvbSB0aGUgcnVuIGNhbGxiYWNrLCB5b3UgbXVzdCBzZXQgdGhlIGRpc3BhdGNoIHByb3BlcnR5XG4gICAqIG9mIHRoZSBlZmZlY3QgdG8gZmFsc2UsIGxpa2UgdGhpczpcbiAgICpcbiAgICogYGBgXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KHtkaXNwYXRjaDogZmFsc2V9KVxuICAgKiAgIHVwZGF0ZVRvZG87IC8vLi4uXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBwZXNzaW1pc3RpY1VwZGF0ZTxBIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uPihcbiAgICBhY3Rpb25UeXBlOiBzdHJpbmcgfCBBY3Rpb25DcmVhdG9yLFxuICAgIG9wdHM6IFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPlxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIG9mVHlwZTxBPihhY3Rpb25UeXBlKSxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpLFxuICAgICAgcGVzc2ltaXN0aWNVcGRhdGUob3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgb3B0aW1pc3RpYyB1cGRhdGVzICh1cGRhdGluZyB0aGUgY2xpZW50IGZpcnN0KS5cbiAgICpcbiAgICogYG9wdGltaXN0aWNVcGRhdGVgIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy0taXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnNcbiAgICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gICAqXG4gICAqIGBvcHRpbWlzdGljVXBkYXRlYCBpcyBkaWZmZXJlbnQgZnJvbSBgcGVzc2ltaXN0aWNVcGRhdGVgLiBJbiBjYXNlIG9mIGEgZmFpbHVyZSwgd2hlbiB1c2luZyBgb3B0aW1pc3RpY1VwZGF0ZWAsXG4gICAqIHRoZSBkZXZlbG9wZXIgYWxyZWFkeSB1cGRhdGVkIHRoZSBzdGF0ZSBsb2NhbGx5LCBzbyB0aGUgZGV2ZWxvcGVyIG11c3QgcHJvdmlkZSBhbiB1bmRvIGFjdGlvbi5cbiAgICpcbiAgICogVGhlIGVycm9yIGhhbmRsaW5nIG11c3QgYmUgZG9uZSBpbiB0aGUgY2FsbGJhY2ssIG9yIGJ5IG1lYW5zIG9mIHRoZSB1bmRvIGFjdGlvbi5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgdXBkYXRlVG9kbyA9IHRoaXMucy5vcHRpbWlzdGljVXBkYXRlPFVwZGF0ZVRvZG8+KCdVUERBVEVfVE9ETycsIHtcbiAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCk7XG4gICAqICAgICB9LFxuICAgKlxuICAgKiAgICAgdW5kb0FjdGlvbjogKGEsIGU6IGFueSkgPT4ge1xuICAgKiAgICAgICAvLyBkaXNwYXRjaCBhbiB1bmRvIGFjdGlvbiB0byB1bmRvIHRoZSBjaGFuZ2VzIGluIHRoZSBjbGllbnQgc3RhdGVcbiAgICogICAgICAgcmV0dXJuICh7XG4gICAqICAgICAgICAgdHlwZTogJ1VORE9fVVBEQVRFX1RPRE8nLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IGFcbiAgICogICAgICAgfSk7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkb24ndCByZXR1cm4gYSBuZXcgYWN0aW9uIGZyb20gdGhlIHJ1biBjYWxsYmFjaywgeW91IG11c3Qgc2V0IHRoZSBkaXNwYXRjaCBwcm9wZXJ0eVxuICAgKiBvZiB0aGUgZWZmZWN0IHRvIGZhbHNlLCBsaWtlIHRoaXM6XG4gICAqXG4gICAqIGBgYFxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCh7ZGlzcGF0Y2g6IGZhbHNlfSlcbiAgICogICB1cGRhdGVUb2RvOyAvLy4uLlxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgb3B0aW1pc3RpY1VwZGF0ZTxBIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uPihcbiAgICBhY3Rpb25UeXBlOiBzdHJpbmcgfCBBY3Rpb25DcmVhdG9yLFxuICAgIG9wdHM6IE9wdGltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgb2ZUeXBlPEE+KGFjdGlvblR5cGUpLFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBvcHRpbWlzdGljVXBkYXRlKG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAd2hhdEl0RG9lcyBIYW5kbGVzIGRhdGEgZmV0Y2hpbmcuXG4gICAqXG4gICAqIERhdGEgZmV0Y2hpbmcgaW1wbGVtZW50ZWQgbmFpdmVseSBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICAgKlxuICAgKiBgZmV0Y2hgIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy0taXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnNcbiAgICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gICAqXG4gICAqICMjIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogQEluamVjdGFibGUoKVxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCgpIGxvYWRUb2RvcyA9IHRoaXMucy5mZXRjaDxHZXRUb2Rvcz4oJ0dFVF9UT0RPUycsIHtcbiAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCkubWFwKHIgPT4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVE9ET1MnLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IHJcbiAgICogICAgICAgfSk7XG4gICAqICAgICB9LFxuICAgKlxuICAgKiAgICAgb25FcnJvcjogKGEsIGU6IGFueSkgPT4ge1xuICAgKiAgICAgICAvLyBkaXNwYXRjaCBhbiB1bmRvIGFjdGlvbiB0byB1bmRvIHRoZSBjaGFuZ2VzIGluIHRoZSBjbGllbnQgc3RhdGVcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGlzIGlzIGNvcnJlY3QsIGJ1dCBiZWNhdXNlIGl0IHNldCB0aGUgY29uY3VycmVuY3kgdG8gMSwgaXQgbWF5IG5vdCBiZSBwZXJmb3JtYW50LlxuICAgKlxuICAgKiBUbyBmaXggdGhhdCwgeW91IGNhbiBwcm92aWRlIHRoZSBgaWRgIGZ1bmN0aW9uLCBsaWtlIHRoaXM6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogQEluamVjdGFibGUoKVxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCgpIGxvYWRUb2RvID0gdGhpcy5zLmZldGNoPEdldFRvZG8+KCdHRVRfVE9ETycsIHtcbiAgICogICAgIGlkOiAoYSwgc3RhdGUpID0+IHtcbiAgICogICAgICAgcmV0dXJuIGEucGF5bG9hZC5pZDtcbiAgICogICAgIH1cbiAgICpcbiAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCkubWFwKHIgPT4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVE9ETycsXG4gICAqICAgICAgICAgcGF5bG9hZDogclxuICAgKiAgICAgICB9KTtcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICBvbkVycm9yOiAoYSwgZTogYW55KSA9PiB7XG4gICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgKiAgICAgICByZXR1cm4gbnVsbDtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBXaXRoIHRoaXMgc2V0dXAsIHRoZSByZXF1ZXN0cyBmb3IgVG9kbyAxIHdpbGwgcnVuIGNvbmN1cnJlbnRseSB3aXRoIHRoZSByZXF1ZXN0cyBmb3IgVG9kbyAyLlxuICAgKlxuICAgKiBJbiBhZGRpdGlvbiwgaWYgRGF0YVBlcnNpc3RlbmNlIG5vdGljZXMgdGhhdCB0aGVyZSBhcmUgbXVsdGlwbGUgcmVxdWVzdHMgZm9yIFRvZG8gMSBzY2hlZHVsZWQsXG4gICAqIGl0IHdpbGwgb25seSBydW4gdGhlIGxhc3Qgb25lLlxuICAgKi9cbiAgZmV0Y2g8QSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbj4oXG4gICAgYWN0aW9uVHlwZTogc3RyaW5nIHwgQWN0aW9uQ3JlYXRvcixcbiAgICBvcHRzOiBGZXRjaE9wdHM8VCwgQT5cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnBpcGUoXG4gICAgICBvZlR5cGU8QT4oYWN0aW9uVHlwZSksXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSxcbiAgICAgIGZldGNoKG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAd2hhdEl0RG9lcyBIYW5kbGVzIGRhdGEgZmV0Y2hpbmcgYXMgcGFydCBvZiByb3V0ZXIgbmF2aWdhdGlvbi5cbiAgICpcbiAgICogRGF0YSBmZXRjaGluZyBpbXBsZW1lbnRlZCBuYWl2ZWx5IHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gICAqXG4gICAqIGBuYXZpZ2F0aW9uYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMuXG4gICAqXG4gICAqIEl0IGNoZWNrcyBpZiBhbiBhY3RpdmF0ZWQgcm91dGVyIHN0YXRlIGNvbnRhaW5zIHRoZSBwYXNzZWQgaW4gY29tcG9uZW50IHR5cGUsIGFuZCwgaWYgaXQgZG9lcywgcnVucyB0aGUgYHJ1bmBcbiAgICogY2FsbGJhY2suIEl0IHByb3ZpZGVzIHRoZSBhY3RpdmF0ZWQgc25hcHNob3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb21wb25lbnQgYW5kIHRoZSBjdXJyZW50IHN0YXRlLiBBbmQgaXQgb25seSBydW5zXG4gICAqIHRoZSBsYXN0IHJlcXVlc3QuXG4gICAqXG4gICAqICMjIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogQEluamVjdGFibGUoKVxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCgpIGxvYWRUb2RvID0gdGhpcy5zLm5hdmlnYXRpb24oVG9kb0NvbXBvbmVudCwge1xuICAgKiAgICAgcnVuOiAoYSwgc3RhdGUpID0+IHtcbiAgICogICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5mZXRjaFRvZG8oYS5wYXJhbXNbJ2lkJ10pLm1hcCh0b2RvID0+ICh7XG4gICAqICAgICAgICAgdHlwZTogJ1RPRE9fTE9BREVEJyxcbiAgICogICAgICAgICBwYXlsb2FkOiB0b2RvXG4gICAqICAgICAgIH0pKTtcbiAgICogICAgIH0sXG4gICAqICAgICBvbkVycm9yOiAoYSwgZTogYW55KSA9PiB7XG4gICAqICAgICAgIC8vIHdlIGNhbiBsb2cgYW5kIGVycm9yIGhlcmUgYW5kIHJldHVybiBudWxsXG4gICAqICAgICAgIC8vIHdlIGNhbiBhbHNvIG5hdmlnYXRlIGJhY2tcbiAgICogICAgICAgcmV0dXJuIG51bGw7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIG5hdmlnYXRpb24oXG4gICAgY29tcG9uZW50OiBUeXBlPGFueT4sXG4gICAgb3B0czogSGFuZGxlTmF2aWdhdGlvbk9wdHM8VD5cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnBpcGUoXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSxcbiAgICAgIG5hdmlnYXRpb24oY29tcG9uZW50LCBvcHRzKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFNuYXBzaG90KFxuICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgczogQWN0aXZhdGVkUm91dGVTbmFwc2hvdFxuKTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB7XG4gIGlmIChzLnJvdXRlQ29uZmlnICYmIHMucm91dGVDb25maWcuY29tcG9uZW50ID09PSBjb21wb25lbnQpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuICBmb3IgKGNvbnN0IGMgb2Ygcy5jaGlsZHJlbikge1xuICAgIGNvbnN0IHNzID0gZmluZFNuYXBzaG90KGNvbXBvbmVudCwgYyk7XG4gICAgaWYgKHNzKSB7XG4gICAgICByZXR1cm4gc3M7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB3cmFwSW50b09ic2VydmFibGU8Tz4ob2JqOiBPYnNlcnZhYmxlPE8+IHwgTyB8IHZvaWQpOiBPYnNlcnZhYmxlPE8+IHtcbiAgaWYgKCEhb2JqICYmIG9iaiBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2UgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gb2YoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2Yob2JqIGFzIE8pO1xuICB9XG59XG4iXX0=