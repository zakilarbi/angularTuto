"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const path = require("path");
const ts = require("typescript");
const workspace_1 = require("@nrwl/workspace");
const init_1 = require("../init/init");
const ast_utils_1 = require("../../utils/ast-utils");
const ast_utils_2 = require("@nrwl/workspace/src/utils/ast-utils");
function addLazyLoadedRouterConfiguration(options) {
    return (host) => {
        const moduleSource = host.read(options.modulePath).toString('utf-8');
        const sourceFile = ts.createSourceFile(options.modulePath, moduleSource, ts.ScriptTarget.Latest, true);
        workspace_1.insert(host, options.modulePath, [
            ast_utils_2.insertImport(sourceFile, options.modulePath, 'RouterModule', '@angular/router'),
            ...ast_utils_1.addImportToModule(sourceFile, options.modulePath, `
        RouterModule.forChild([
        /* {path: '', pathMatch: 'full', component: InsertYourComponentHere} */
       ]) `)
        ]);
        return host;
    };
}
function addRouterConfiguration(options) {
    return (host) => {
        const moduleSource = host.read(options.modulePath).toString('utf-8');
        const moduleSourceFile = ts.createSourceFile(options.modulePath, moduleSource, ts.ScriptTarget.Latest, true);
        const constName = `${workspace_1.toPropertyName(options.fileName)}Routes`;
        workspace_1.insert(host, options.modulePath, [
            ast_utils_2.insertImport(moduleSourceFile, options.modulePath, 'RouterModule, Route', '@angular/router'),
            ...ast_utils_1.addImportToModule(moduleSourceFile, options.modulePath, `RouterModule`),
            ...workspace_1.addGlobal(moduleSourceFile, options.modulePath, `export const ${constName}: Route[] = [];`)
        ]);
        return host;
    };
}
function addLoadChildren(options) {
    return (host) => {
        const npmScope = workspace_1.getNpmScope(host);
        if (!host.exists(options.parentModule)) {
            throw new Error(`Cannot find '${options.parentModule}'`);
        }
        const moduleSource = host.read(options.parentModule).toString('utf-8');
        const sourceFile = ts.createSourceFile(options.parentModule, moduleSource, ts.ScriptTarget.Latest, true);
        workspace_1.insert(host, options.parentModule, [
            ...ast_utils_1.addRoute(options.parentModule, sourceFile, `{path: '${workspace_1.toFileName(options.fileName)}', loadChildren: () => import('@${npmScope}/${options.projectDirectory}').then(module => module.${options.moduleName})}`)
        ]);
        const tsConfig = findClosestTsConfigApp(host, options.parentModule);
        if (tsConfig) {
            const tsConfigAppSource = host.read(tsConfig).toString('utf-8');
            const tsConfigAppFile = ts.createSourceFile(tsConfig, tsConfigAppSource, ts.ScriptTarget.Latest, true);
            const offset = workspace_1.offsetFromRoot(path.dirname(tsConfig));
            workspace_1.insert(host, tsConfig, [
                ...workspace_1.addIncludeToTsConfig(tsConfig, tsConfigAppFile, `\n    , "${offset}${options.projectRoot}/src/index.ts"\n`)
            ]);
        }
        else {
            // we should warn the user about not finding the config
        }
        return host;
    };
}
function findClosestTsConfigApp(host, parentModule) {
    const dir = path.parse(parentModule).dir;
    if (host.exists(`${dir}/tsconfig.app.json`)) {
        return `${dir}/tsconfig.app.json`;
    }
    else if (dir != '') {
        return findClosestTsConfigApp(host, dir);
    }
    else {
        return null;
    }
}
function addChildren(options) {
    return (host) => {
        const npmScope = workspace_1.getNpmScope(host);
        if (!host.exists(options.parentModule)) {
            throw new Error(`Cannot find '${options.parentModule}'`);
        }
        const moduleSource = host.read(options.parentModule).toString('utf-8');
        const sourceFile = ts.createSourceFile(options.parentModule, moduleSource, ts.ScriptTarget.Latest, true);
        const constName = `${workspace_1.toPropertyName(options.fileName)}Routes`;
        const importPath = `@${npmScope}/${options.projectDirectory}`;
        workspace_1.insert(host, options.parentModule, [
            ast_utils_2.insertImport(sourceFile, options.parentModule, `${options.moduleName}, ${constName}`, importPath),
            ...ast_utils_1.addImportToModule(sourceFile, options.parentModule, options.moduleName),
            ...ast_utils_1.addRoute(options.parentModule, sourceFile, `{path: '${workspace_1.toFileName(options.fileName)}', children: ${constName}}`)
        ]);
        return host;
    };
}
function updateNgPackage(options) {
    if (!options.publishable) {
        return schematics_1.noop();
    }
    const dest = `${workspace_1.offsetFromRoot(options.projectRoot)}dist/libs/${options.projectDirectory}`;
    return schematics_1.chain([
        workspace_1.updateJsonInTree(`${options.projectRoot}/ng-package.json`, json => {
            let $schema = json.$schema;
            if (json.$schema && json.$schema.indexOf('node_modules') >= 0) {
                $schema = `${workspace_1.offsetFromRoot(options.projectRoot)}${json.$schema.substring(json.$schema.indexOf('node_modules'), json.$schema.length)}`;
            }
            return Object.assign(Object.assign({}, json), { dest,
                $schema });
        })
    ]);
}
function updateProject(options) {
    return (host, context) => {
        const libRoot = `${options.projectRoot}/src/lib/`;
        host.delete(path.join(libRoot, `${options.name}.service.ts`));
        host.delete(path.join(libRoot, `${options.name}.service.spec.ts`));
        host.delete(path.join(libRoot, `${options.name}.component.ts`));
        host.delete(path.join(libRoot, `${options.name}.component.spec.ts`));
        if (!options.publishable) {
            host.delete(path.join(options.projectRoot, 'ng-package.json'));
            host.delete(path.join(options.projectRoot, 'package.json'));
            host.delete(path.join(options.projectRoot, 'tsconfig.lib.prod.json'));
        }
        host.delete(path.join(options.projectRoot, 'karma.conf.js'));
        host.delete(path.join(options.projectRoot, 'src/test.ts'));
        host.delete(path.join(options.projectRoot, 'tsconfig.spec.json'));
        host.delete(path.join(libRoot, `${options.name}.module.ts`));
        host.create(path.join(libRoot, `${options.fileName}.module.ts`), `
        import { NgModule } from '@angular/core';
        import { CommonModule } from '@angular/common';
        
        @NgModule({
          imports: [
            CommonModule
          ]
        })
        export class ${options.moduleName} { }
        `);
        if (options.unitTestRunner !== 'none') {
            host.create(path.join(libRoot, `${options.fileName}.module.spec.ts`), `
    import { async, TestBed } from '@angular/core/testing';
    import { ${options.moduleName} } from './${options.fileName}.module';
    
    describe('${options.moduleName}', () => {
      beforeEach(async(() => {
        TestBed.configureTestingModule({
          imports: [ ${options.moduleName} ]
        })
        .compileComponents();
      }));
    
      it('should create', () => {
        expect(${options.moduleName}).toBeDefined();
      });
    });
          `);
        }
        host.overwrite(`${options.projectRoot}/src/index.ts`, `
        export * from './lib/${options.fileName}.module';
        `);
        return schematics_1.chain([
            schematics_1.mergeWith(schematics_1.apply(schematics_1.url('./files/lib'), [
                schematics_1.template(Object.assign(Object.assign({}, options), { offsetFromRoot: workspace_1.offsetFromRoot(options.projectRoot) })),
                schematics_1.move(options.projectRoot)
            ]), schematics_1.MergeStrategy.Overwrite),
            workspace_1.updateJsonInTree(workspace_1.getWorkspacePath(host), json => {
                const project = json.projects[options.name];
                const fixedProject = workspace_1.replaceAppNameWithPath(project, options.name, options.projectRoot);
                fixedProject.schematics = fixedProject.schematics || {};
                if (options.style !== 'css') {
                    fixedProject.schematics = Object.assign(Object.assign({}, fixedProject.schematics), { '@nrwl/angular:component': {
                            style: options.style
                        } });
                }
                if (!options.publishable) {
                    delete fixedProject.architect.build;
                }
                else {
                    // adjust the builder path to our custom one
                    fixedProject.architect.build.builder = '@nrwl/angular:package';
                }
                delete fixedProject.architect.test;
                fixedProject.architect.lint.options.tsConfig = fixedProject.architect.lint.options.tsConfig.filter(path => path !== core_1.join(core_1.normalize(options.projectRoot), 'tsconfig.spec.json'));
                fixedProject.architect.lint.options.exclude.push('!' + core_1.join(core_1.normalize(options.projectRoot), '**'));
                json.projects[options.name] = fixedProject;
                return json;
            }),
            workspace_1.updateJsonInTree(`${options.projectRoot}/tsconfig.lib.json`, json => {
                if (options.unitTestRunner === 'jest') {
                    json.exclude = ['src/test-setup.ts', '**/*.spec.ts'];
                }
                else if (options.unitTestRunner === 'none') {
                    json.exclude = [];
                }
                else {
                    json.exclude = json.exclude || [];
                }
                return Object.assign(Object.assign({}, json), { extends: `./tsconfig.json`, compilerOptions: Object.assign(Object.assign({}, json.compilerOptions), { outDir: `${workspace_1.offsetFromRoot(options.projectRoot)}dist/out-tsc` }) });
            }),
            workspace_1.updateJsonInTree(`${options.projectRoot}/tslint.json`, json => {
                return Object.assign(Object.assign({}, json), { extends: `${workspace_1.offsetFromRoot(options.projectRoot)}tslint.json`, linterOptions: {
                        exclude: ['!**/*']
                    } });
            }),
            workspace_1.updateJsonInTree(`/nx.json`, json => {
                return Object.assign(Object.assign({}, json), { projects: Object.assign(Object.assign({}, json.projects), { [options.name]: { tags: options.parsedTags } }) });
            }),
            updateNgPackage(options)
        ])(host, context);
    };
}
function updateTsConfig(options) {
    return schematics_1.chain([
        (host, context) => {
            const nxJson = workspace_1.readJsonInTree(host, 'nx.json');
            return workspace_1.updateJsonInTree('tsconfig.json', json => {
                const c = json.compilerOptions;
                delete c.paths[options.name];
                c.paths[`@${nxJson.npmScope}/${options.projectDirectory}`] = [
                    `libs/${options.projectDirectory}/src/index.ts`
                ];
                return json;
            })(host, context);
        }
    ]);
}
function updateLibPackageNpmScope(options) {
    return (host) => {
        return workspace_1.updateJsonInTree(`${options.projectRoot}/package.json`, json => {
            json.name = `@${workspace_1.getNpmScope(host)}/${options.name}`;
            return json;
        });
    };
}
function addModule(options) {
    return schematics_1.chain([
        options.routing && options.lazy
            ? addLazyLoadedRouterConfiguration(options)
            : schematics_1.noop(),
        options.routing && options.lazy && options.parentModule
            ? addLoadChildren(options)
            : schematics_1.noop(),
        options.routing && !options.lazy ? addRouterConfiguration(options) : schematics_1.noop(),
        options.routing && !options.lazy && options.parentModule
            ? addChildren(options)
            : schematics_1.noop()
    ]);
}
function default_1(schema) {
    return (host, context) => {
        const options = normalizeOptions(host, schema);
        if (!options.routing && options.lazy) {
            throw new Error(`routing must be set`);
        }
        return schematics_1.chain([
            workspace_1.addLintFiles(options.projectRoot, "tslint" /* TsLint */, { onlyGlobal: true }),
            init_1.addUnitTestRunner(options),
            schematics_1.externalSchematic('@schematics/angular', 'library', {
                name: options.name,
                prefix: options.prefix,
                style: options.style,
                entryFile: 'index',
                skipPackageJson: !options.publishable,
                skipTsConfig: true
            }),
            schematics_1.move(options.name, options.projectRoot),
            updateProject(options),
            updateTsConfig(options),
            options.unitTestRunner === 'jest'
                ? schematics_1.externalSchematic('@nrwl/jest', 'jest-project', {
                    project: options.name,
                    setupFile: 'angular',
                    supportTsx: false,
                    skipSerializers: false
                })
                : schematics_1.noop(),
            options.unitTestRunner === 'karma'
                ? schematics_1.schematic('karma-project', {
                    project: options.name
                })
                : schematics_1.noop(),
            options.publishable ? updateLibPackageNpmScope(options) : schematics_1.noop(),
            addModule(options),
            workspace_1.formatFiles(options)
        ])(host, context);
    };
}
exports.default = default_1;
function normalizeOptions(host, options) {
    const name = workspace_1.toFileName(options.name);
    const projectDirectory = options.directory
        ? `${workspace_1.toFileName(options.directory)}/${name}`
        : name;
    const projectName = projectDirectory.replace(new RegExp('/', 'g'), '-');
    const fileName = options.simpleModuleName ? name : projectName;
    const projectRoot = `libs/${projectDirectory}`;
    const moduleName = `${workspace_1.toClassName(fileName)}Module`;
    const parsedTags = options.tags
        ? options.tags.split(',').map(s => s.trim())
        : [];
    const modulePath = `${projectRoot}/src/lib/${fileName}.module.ts`;
    const defaultPrefix = workspace_1.getNpmScope(host);
    return Object.assign(Object.assign({}, options), { prefix: options.prefix ? options.prefix : defaultPrefix, name: projectName, projectRoot, entryFile: 'index', moduleName,
        projectDirectory,
        modulePath,
        parsedTags,
        fileName });
}
