"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const devkitArchitect = require("@angular-devkit/architect");
const architect_1 = require("@angular-devkit/architect");
const testing_1 = require("@angular-devkit/architect/testing");
const core_1 = require("@angular-devkit/core");
const fsUtility = require("@nrwl/workspace");
const testing_2 = require("@nrwl/workspace/testing");
const child_process = require("child_process");
const events_1 = require("events");
const fsExtras = require("fs-extra");
const path = require("path");
const rxjs_1 = require("rxjs");
const cypress_impl_1 = require("./cypress.impl");
jest.mock('../../utils/cypress-version');
const cypress_version_1 = require("../../utils/cypress-version");
const Cypress = require('cypress');
describe('Cypress builder', () => {
    let architect;
    let cypressRun;
    let cypressOpen;
    let fakeEventEmitter;
    let fork;
    let cypressConfig;
    let mockedBuilderContext;
    let mockedInstalledCypressVersion = cypress_version_1.installedCypressVersion;
    const cypressBuilderOptions = {
        cypressConfig: 'apps/my-app-e2e/cypress.json',
        parallel: false,
        tsConfig: 'apps/my-app-e2e/tsconfig.json',
        devServerTarget: 'my-app:serve',
        headless: true,
        exit: true,
        record: false,
        baseUrl: undefined,
        watch: false
    };
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        const registry = new core_1.schema.CoreSchemaRegistry();
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        const testArchitectHost = new testing_1.TestingArchitectHost('/root', '/root');
        architect = new architect_1.Architect(testArchitectHost, registry);
        yield testArchitectHost.addBuilderFromPackage(path.join(__dirname, '../../..'));
        mockedBuilderContext = new testing_2.MockBuilderContext(architect, testArchitectHost);
        devkitArchitect.scheduleTargetAndForget = jest
            .fn()
            .mockReturnValue(rxjs_1.of({
            success: true,
            baseUrl: 'http://localhost:4200'
        }));
        fakeEventEmitter = new events_1.EventEmitter();
        fork = spyOn(child_process, 'fork').and.returnValue(fakeEventEmitter);
        cypressRun = spyOn(Cypress, 'run').and.returnValue(Promise.resolve({}));
        cypressOpen = spyOn(Cypress, 'open').and.returnValue(Promise.resolve({}));
        cypressConfig = {
            fixturesFolder: './src/fixtures',
            integrationFolder: './src/integration'
        };
        spyOn(fsUtility, 'readJsonFile').and.callFake(path => {
            return path.endsWith('tsconfig.json')
                ? {
                    compilerOptions: {
                        outDir: '../../dist/out-tsc/apps/my-app-e2e/src'
                    }
                }
                : cypressConfig;
        });
        spyOn(fsExtras, 'copySync');
        spyOn(process, 'exit');
    }));
    it('should call `Cypress.run` if headless mode is `true`', (done) => __awaiter(void 0, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', cypressBuilderOptions);
        run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
            yield run.stop();
            expect(cypressRun).toHaveBeenCalledWith(jasmine.objectContaining({
                config: { baseUrl: 'http://localhost:4200' },
                project: path.dirname(cypressBuilderOptions.cypressConfig)
            }));
            expect(cypressOpen).not.toHaveBeenCalled();
            done();
        }));
        fakeEventEmitter.emit('exit', 0); // Passing tsc command
    }));
    it('should call `Cypress.open` if headless mode is `false`', (done) => __awaiter(void 0, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', Object.assign(Object.assign({}, cypressBuilderOptions), { headless: false, watch: true }));
        run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
            yield run.stop();
            expect(cypressOpen).toHaveBeenCalledWith(jasmine.objectContaining({
                config: { baseUrl: 'http://localhost:4200' },
                project: path.dirname(cypressBuilderOptions.cypressConfig)
            }));
            expect(cypressRun).not.toHaveBeenCalled();
            done();
        }));
        fakeEventEmitter.emit('exit', 0); // Passing tsc command
    }));
    it('should call `Cypress.run` with provided baseUrl', (done) => __awaiter(void 0, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', Object.assign(Object.assign({}, cypressBuilderOptions), { devServerTarget: undefined, baseUrl: 'http://my-distant-host.com' }));
        run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
            yield run.stop();
            expect(cypressRun).toHaveBeenCalledWith(jasmine.objectContaining({
                config: {
                    baseUrl: 'http://my-distant-host.com'
                },
                project: path.dirname(cypressBuilderOptions.cypressConfig)
            }));
            done();
            expect(cypressOpen).not.toHaveBeenCalled();
        }));
        fakeEventEmitter.emit('exit', 0); // Passing tsc command
    }));
    it('should call `Cypress.run` with provided browser', (done) => __awaiter(void 0, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', Object.assign(Object.assign({}, cypressBuilderOptions), { browser: 'chrome' }));
        run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
            yield run.stop();
            expect(cypressRun).toHaveBeenCalledWith(jasmine.objectContaining({
                browser: 'chrome',
                project: path.dirname(cypressBuilderOptions.cypressConfig)
            }));
            expect(cypressOpen).not.toHaveBeenCalled();
            done();
        }));
        fakeEventEmitter.emit('exit', 0); // Passing tsc command
    }));
    it('should call `Cypress.run` without baseUrl nor dev server target value', (done) => __awaiter(void 0, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', {
            cypressConfig: 'apps/my-app-e2e/cypress.json',
            tsConfig: 'apps/my-app-e2e/tsconfig.json',
            devServerTarget: undefined,
            headless: true,
            exit: true,
            parallel: false,
            record: false,
            baseUrl: undefined,
            watch: false
        });
        run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
            yield run.stop();
            expect(cypressRun).toHaveBeenCalledWith(jasmine.objectContaining({
                project: path.dirname(cypressBuilderOptions.cypressConfig)
            }));
            expect(cypressOpen).not.toHaveBeenCalled();
            done();
        }));
        fakeEventEmitter.emit('exit', 0); // Passing tsc command
    }));
    it('should fail early if application build fails', (done) => __awaiter(void 0, void 0, void 0, function* () {
        devkitArchitect.scheduleTargetAndForget = jest
            .fn()
            .mockReturnValue(rxjs_1.of({
            success: false
        }));
        const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', cypressBuilderOptions);
        run.result.then((res) => __awaiter(void 0, void 0, void 0, function* () {
            yield run.stop();
            expect(res.success).toBe(false);
            done();
        }));
    }));
    it('should call `Cypress.run` with provided cypressConfig as project and configFile', (done) => __awaiter(void 0, void 0, void 0, function* () {
        const cfg = Object.assign(Object.assign({}, cypressBuilderOptions), { cypressConfig: 'some/project/my-cypress.json' });
        const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', cfg);
        run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
            yield run.stop();
            expect(cypressRun).toHaveBeenCalledWith(jasmine.objectContaining({
                project: path.dirname(cfg.cypressConfig),
                configFile: path.basename(cfg.cypressConfig)
            }));
            expect(cypressOpen).not.toHaveBeenCalled();
            done();
        }));
        fakeEventEmitter.emit('exit', 0); // Passing tsc command
    }));
    it('should show warnings if using unsupported browsers v3', (done) => __awaiter(void 0, void 0, void 0, function* () {
        mockedInstalledCypressVersion.mockReturnValue(3);
        const result = yield cypress_impl_1.cypressBuilderRunner(Object.assign(Object.assign({}, cypressBuilderOptions), { browser: 'edge' }), mockedBuilderContext).toPromise();
        expect(mockedBuilderContext.logger.includes('You are using a browser that is not supported by cypress v3.')).toBeTruthy();
        done();
    }));
    it('should show warnings if using unsupported browsers v4', (done) => __awaiter(void 0, void 0, void 0, function* () {
        mockedInstalledCypressVersion.mockReturnValue(4);
        const result = yield cypress_impl_1.cypressBuilderRunner(Object.assign(Object.assign({}, cypressBuilderOptions), { browser: 'canary' }), mockedBuilderContext).toPromise();
        expect(mockedBuilderContext.logger.includes('You are using a browser that is not supported by cypress v4+.')).toBeTruthy();
        done();
    }));
    describe('legacy', () => {
        beforeEach(() => {
            cypressConfig = {
                fixturesFolder: '../../dist/out-tsc/apps/my-app-e2e/src/fixtures',
                integrationFolder: '../../dist/out-tsc/apps/my-app-e2e/src/integration'
            };
        });
        it('should call `fork.child_process` with the tsc command', () => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', cypressBuilderOptions);
            fakeEventEmitter.emit('exit', 0);
            yield run.result;
            yield run.stop();
            expect(fork).toHaveBeenCalledWith('/root/node_modules/typescript/bin/tsc', ['-p', '/root/apps/my-app-e2e/tsconfig.json'], { stdio: [0, 1, 2, 'ipc'] });
        }));
        it('should copy fixtures folder to out-dir', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', cypressBuilderOptions);
            run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
                yield run.stop();
                expect(fsExtras.copySync).toHaveBeenCalledWith('/root/apps/my-app-e2e/src/fixtures', '/root/dist/out-tsc/apps/my-app-e2e/src/fixtures', { overwrite: true });
                done();
            }));
            fakeEventEmitter.emit('exit', 0); // Passing tsc command
        }));
        it('should not copy fixtures folder if they are not defined in the cypress config', (done) => __awaiter(void 0, void 0, void 0, function* () {
            delete cypressConfig.fixturesFolder;
            const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', cypressBuilderOptions);
            run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
                yield run.stop();
                expect(fsExtras.copySync).not.toHaveBeenCalled();
                done();
            }));
            fakeEventEmitter.emit('exit', 0); // Passing tsc command
        }));
        it('should copy regex files to out-dir', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const regex = '^.+\\.feature$';
            const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', Object.assign(Object.assign({}, cypressBuilderOptions), { copyFiles: regex }));
            run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
                yield run.stop();
                expect(fsExtras.copySync).toHaveBeenCalledWith('/root/apps/my-app-e2e/src/integration', '/root/dist/out-tsc/apps/my-app-e2e/src/integration', { filter: jasmine.any(Function) });
                done();
            }));
            fakeEventEmitter.emit('exit', 0); // Passing tsc command
        }));
        it('should not copy regex files if the regex is not defined', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const regex = undefined;
            const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', Object.assign(Object.assign({}, cypressBuilderOptions), { copyFiles: regex }));
            run.result.then(() => __awaiter(void 0, void 0, void 0, function* () {
                yield run.stop();
                expect(fsExtras.copySync).not.toHaveBeenCalledWith('/root/apps/my-app-e2e/src/integration', '/root/dist/out-tsc/apps/my-app-e2e/src/integration', { filter: jasmine.any(Function) });
                done();
            }));
            fakeEventEmitter.emit('exit', 0); // Passing tsc command
        }));
        it('should not copy regex files if the integration files are not defined in the cypress config', (done) => __awaiter(void 0, void 0, void 0, function* () {
            delete cypressConfig.integrationFolder;
            const regex = '^.+\\.feature$';
            const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', Object.assign(Object.assign({}, cypressBuilderOptions), { copyFiles: regex }));
            run.result
                .then(() => __awaiter(void 0, void 0, void 0, function* () {
                yield run.stop();
                fail();
            }))
                .catch(() => __awaiter(void 0, void 0, void 0, function* () {
                yield run.stop();
                done();
            }));
            fakeEventEmitter.emit('exit', 0); // Passing tsc command
        }));
        it('should fail early if integration files fail to compile', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/cypress:cypress', cypressBuilderOptions);
            run.result.then((res) => __awaiter(void 0, void 0, void 0, function* () {
                yield run.stop();
                expect(res.success).toBe(false);
                done();
            }));
            fakeEventEmitter.emit('exit', 1); // Passing tsc command
        }));
    });
});
