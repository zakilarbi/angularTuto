"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const testing_1 = require("@angular-devkit/architect/testing");
const core_1 = require("@angular-devkit/core");
const path = require("path");
describe('Jest Builder', () => {
    let architect;
    let runCLI;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        jest.resetModules();
        runCLI = jest.fn();
        jest.doMock('jest', () => ({
            runCLI
        }));
        const registry = new core_1.schema.CoreSchemaRegistry();
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        const testArchitectHost = new testing_1.TestingArchitectHost('/root', '/root');
        architect = new architect_1.Architect(testArchitectHost, registry);
        yield testArchitectHost.addBuilderFromPackage(path.join(__dirname, '../../..'));
        runCLI.mockReturnValue(Promise.resolve({
            results: {
                success: true
            }
        }));
    }));
    describe('when the jest config file is untouched', () => {
        beforeEach(() => {
            jest.doMock('/root/jest.config.js', () => ({
                transform: {
                    '^.+\\.[tj]sx?$': 'ts-jest'
                }
            }), { virtual: true });
        });
        it('should send appropriate options to jestCLI', () => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
                jestConfig: './jest.config.js',
                tsConfig: './tsconfig.test.json',
                watch: false
            });
            expect(yield run.result).toEqual(jasmine.objectContaining({
                success: true
            }));
            expect(runCLI).toHaveBeenCalledWith({
                _: [],
                globals: JSON.stringify({
                    'ts-jest': {
                        tsConfig: '/root/tsconfig.test.json',
                        stringifyContentPathRegex: '\\.(html|svg)$',
                        astTransformers: [
                            'jest-preset-angular/build/InlineFilesTransformer',
                            'jest-preset-angular/build/StripStylesTransformer'
                        ]
                    }
                }),
                testPathPattern: [],
                watch: false
            }, ['/root/jest.config.js']);
        }));
        it('should send appropriate options to jestCLI when testFile is specified', () => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
                testFile: 'lib.spec.ts',
                jestConfig: './jest.config.js',
                tsConfig: './tsconfig.test.json',
                codeCoverage: false,
                runInBand: true,
                testNamePattern: 'should load',
                testPathPattern: ['/test/path'],
                colors: false,
                reporters: ['/test/path'],
                verbose: false,
                coverageReporters: 'test',
                coverageDirectory: '/test/path',
                watch: false
            });
            expect(yield run.result).toEqual(jasmine.objectContaining({
                success: true
            }));
            expect(runCLI).toHaveBeenCalledWith({
                _: ['lib.spec.ts'],
                globals: JSON.stringify({
                    'ts-jest': {
                        tsConfig: '/root/tsconfig.test.json',
                        stringifyContentPathRegex: '\\.(html|svg)$',
                        astTransformers: [
                            'jest-preset-angular/build/InlineFilesTransformer',
                            'jest-preset-angular/build/StripStylesTransformer'
                        ]
                    }
                }),
                coverage: false,
                runInBand: true,
                testNamePattern: 'should load',
                testPathPattern: ['/test/path'],
                colors: false,
                reporters: ['/test/path'],
                verbose: false,
                coverageReporters: 'test',
                coverageDirectory: '/test/path',
                watch: false
            }, ['/root/jest.config.js']);
        }));
        it('should send appropriate options to jestCLI when findRelatedTests is specified', () => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
                findRelatedTests: 'file1.ts,file2.ts',
                jestConfig: './jest.config.js',
                tsConfig: './tsconfig.test.json',
                codeCoverage: false,
                runInBand: true,
                testNamePattern: 'should load',
                watch: false
            });
            expect(yield run.result).toEqual(jasmine.objectContaining({
                success: true
            }));
            expect(runCLI).toHaveBeenCalledWith({
                _: ['file1.ts', 'file2.ts'],
                globals: JSON.stringify({
                    'ts-jest': {
                        tsConfig: '/root/tsconfig.test.json',
                        stringifyContentPathRegex: '\\.(html|svg)$',
                        astTransformers: [
                            'jest-preset-angular/build/InlineFilesTransformer',
                            'jest-preset-angular/build/StripStylesTransformer'
                        ]
                    }
                }),
                coverage: false,
                findRelatedTests: true,
                runInBand: true,
                testNamePattern: 'should load',
                testPathPattern: [],
                watch: false
            }, ['/root/jest.config.js']);
        }));
        it('should send other options to jestCLI', () => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
                jestConfig: './jest.config.js',
                tsConfig: './tsconfig.test.json',
                codeCoverage: true,
                bail: 1,
                color: false,
                ci: true,
                json: true,
                maxWorkers: 2,
                onlyChanged: true,
                outputFile: 'abc.txt',
                passWithNoTests: true,
                silent: true,
                testNamePattern: 'test',
                testPathPattern: ['/test/path'],
                colors: false,
                reporters: ['/test/path'],
                verbose: false,
                coverageReporters: 'test',
                coverageDirectory: '/test/path',
                testResultsProcessor: 'results-processor',
                updateSnapshot: true,
                useStderr: true,
                watch: false,
                watchAll: false,
                testLocationInResults: true
            });
            expect(yield run.result).toEqual(jasmine.objectContaining({
                success: true
            }));
            expect(runCLI).toHaveBeenCalledWith({
                _: [],
                globals: JSON.stringify({
                    'ts-jest': {
                        tsConfig: '/root/tsconfig.test.json',
                        stringifyContentPathRegex: '\\.(html|svg)$',
                        astTransformers: [
                            'jest-preset-angular/build/InlineFilesTransformer',
                            'jest-preset-angular/build/StripStylesTransformer'
                        ]
                    }
                }),
                coverage: true,
                bail: 1,
                color: false,
                ci: true,
                json: true,
                maxWorkers: 2,
                onlyChanged: true,
                outputFile: 'abc.txt',
                passWithNoTests: true,
                silent: true,
                testNamePattern: 'test',
                testPathPattern: ['/test/path'],
                colors: false,
                verbose: false,
                reporters: ['/test/path'],
                coverageReporters: 'test',
                coverageDirectory: '/test/path',
                testResultsProcessor: 'results-processor',
                updateSnapshot: true,
                useStderr: true,
                watch: false,
                watchAll: false,
                testLocationInResults: true
            }, ['/root/jest.config.js']);
        }));
        it('should send the main to runCLI', () => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
                jestConfig: './jest.config.js',
                tsConfig: './tsconfig.test.json',
                setupFile: './test-setup.ts',
                watch: false
            });
            expect(yield run.result).toEqual(jasmine.objectContaining({
                success: true
            }));
            expect(runCLI).toHaveBeenCalledWith({
                _: [],
                globals: JSON.stringify({
                    'ts-jest': {
                        tsConfig: '/root/tsconfig.test.json',
                        stringifyContentPathRegex: '\\.(html|svg)$',
                        astTransformers: [
                            'jest-preset-angular/build/InlineFilesTransformer',
                            'jest-preset-angular/build/StripStylesTransformer'
                        ]
                    }
                }),
                setupFilesAfterEnv: ['/root/test-setup.ts'],
                testPathPattern: [],
                watch: false
            }, ['/root/jest.config.js']);
        }));
        it('should return the proper result', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
                jestConfig: './jest.config.js',
                tsConfig: './tsconfig.test.json',
                watch: false
            });
            expect(yield run.result).toEqual(jasmine.objectContaining({
                success: true
            }));
            done();
        }));
    });
    describe('when the jest config file has been modified', () => {
        beforeAll(() => {
            jest.doMock('/root/jest.config.js', () => ({
                transform: {
                    '^.+\\.[tj]sx?$': 'ts-jest'
                },
                globals: { hereToStay: true, 'ts-jest': { diagnostics: false } }
            }), { virtual: true });
        });
        it('should merge the globals property from jest config', () => __awaiter(void 0, void 0, void 0, function* () {
            yield architect.scheduleBuilder('@nrwl/jest:jest', {
                jestConfig: './jest.config.js',
                tsConfig: './tsconfig.test.json',
                setupFile: './test-setup.ts',
                watch: false
            });
            expect(runCLI).toHaveBeenCalledWith({
                _: [],
                globals: JSON.stringify({
                    hereToStay: true,
                    'ts-jest': {
                        diagnostics: false,
                        tsConfig: '/root/tsconfig.test.json',
                        stringifyContentPathRegex: '\\.(html|svg)$',
                        astTransformers: [
                            'jest-preset-angular/build/InlineFilesTransformer',
                            'jest-preset-angular/build/StripStylesTransformer'
                        ]
                    }
                }),
                setupFilesAfterEnv: ['/root/test-setup.ts'],
                testPathPattern: [],
                watch: false
            }, ['/root/jest.config.js']);
        }));
    });
    describe('when we use babel-jest', () => {
        beforeEach(() => {
            jest.doMock('/root/jest.config.js', () => ({
                transform: {
                    '^.+\\.[tj]sx?$': 'babel-jest'
                }
            }), { virtual: true });
        });
        it('should send appropriate options to jestCLI', () => __awaiter(void 0, void 0, void 0, function* () {
            const options = {
                jestConfig: './jest.config.js',
                tsConfig: './tsconfig.test.json',
                watch: false
            };
            const run = yield architect.scheduleBuilder('@nrwl/jest:jest', options);
            expect(yield run.result).toEqual(jasmine.objectContaining({
                success: true
            }));
            expect(runCLI).toHaveBeenCalledWith({
                _: [],
                globals: '{}',
                testPathPattern: [],
                watch: false
            }, ['/root/jest.config.js']);
        }));
    });
    describe('when the user tries to use babel-jest AND ts-jest', () => {
        beforeEach(() => {
            jest.doMock('/root/jest.config.js', () => ({
                transform: {
                    '^.+\\.tsx?$': 'ts-jest',
                    '^.+\\.jsx?$': 'babel-jest'
                }
            }), { virtual: true });
        });
        it('should throw an appropriate error', () => __awaiter(void 0, void 0, void 0, function* () {
            const options = {
                jestConfig: './jest.config.js',
                tsConfig: './tsconfig.test.json',
                watch: false
            };
            const run = yield architect.scheduleBuilder('@nrwl/jest:jest', options);
            yield expect(run.result).rejects.toThrow(/Using babel-jest and ts-jest together is not supported/);
        }));
    });
});
