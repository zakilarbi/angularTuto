"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@nrwl/workspace");
const testing_1 = require("@nrwl/workspace/testing");
const testing_2 = require("../../utils/testing");
describe('jestProject', () => {
    let appTree;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        appTree = schematics_1.Tree.empty();
        appTree = testing_1.createEmptyWorkspace(appTree);
        appTree = yield testing_2.callRule(workspace_1.updateJsonInTree('workspace.json', json => {
            json.projects.lib1 = {
                root: 'libs/lib1',
                architect: {
                    lint: {
                        builder: '@angular-devkit/build-angular:tslint',
                        options: {
                            tsConfig: []
                        }
                    }
                }
            };
            return json;
        }), appTree);
        appTree = yield testing_2.callRule(workspace_1.updateJsonInTree('libs/lib1/tsconfig.json', json => {
            return {
                compilerOptions: {
                    types: []
                }
            };
        }), appTree);
    }));
    it('should generate files', () => __awaiter(void 0, void 0, void 0, function* () {
        const resultTree = yield testing_2.runSchematic('jest-project', {
            project: 'lib1',
            setupFile: 'angular'
        }, appTree);
        expect(resultTree.exists('/libs/lib1/src/test-setup.ts')).toBeTruthy();
        expect(resultTree.exists('/libs/lib1/jest.config.js')).toBeTruthy();
        expect(resultTree.exists('/libs/lib1/tsconfig.spec.json')).toBeTruthy();
    }));
    it('should alter workspace.json', () => __awaiter(void 0, void 0, void 0, function* () {
        const resultTree = yield testing_2.runSchematic('jest-project', {
            project: 'lib1',
            setupFile: 'angular'
        }, appTree);
        const workspaceJson = workspace_1.readJsonInTree(resultTree, 'workspace.json');
        expect(workspaceJson.projects.lib1.architect.test).toEqual({
            builder: '@nrwl/jest:jest',
            options: {
                jestConfig: 'libs/lib1/jest.config.js',
                setupFile: 'libs/lib1/src/test-setup.ts',
                tsConfig: 'libs/lib1/tsconfig.spec.json',
                passWithNoTests: true
            }
        });
        expect(workspaceJson.projects.lib1.architect.lint.options.tsConfig).toContain('libs/lib1/tsconfig.spec.json');
    }));
    it('should create a jest.config.js', () => __awaiter(void 0, void 0, void 0, function* () {
        const resultTree = yield testing_2.runSchematic('jest-project', {
            project: 'lib1'
        }, appTree);
        expect(resultTree.readContent('libs/lib1/jest.config.js'))
            .toBe(`module.exports = {
  name: 'lib1',
  preset: '../../jest.config.js',
  coverageDirectory: '../../coverage/libs/lib1',
  snapshotSerializers: [
    'jest-preset-angular/build/AngularNoNgAttributesSnapshotSerializer.js',
    'jest-preset-angular/build/AngularSnapshotSerializer.js',
    'jest-preset-angular/build/HTMLCommentSerializer.js'
  ]
};
`);
    }));
    it('should update the local tsconfig.json', () => __awaiter(void 0, void 0, void 0, function* () {
        const resultTree = yield testing_2.runSchematic('jest-project', {
            project: 'lib1'
        }, appTree);
        const tsConfig = workspace_1.readJsonInTree(resultTree, 'libs/lib1/tsconfig.json');
        expect(tsConfig.compilerOptions.types).toContain('jest');
        expect(tsConfig.compilerOptions.types).toContain('node');
    }));
    it('should create a tsconfig.spec.json', () => __awaiter(void 0, void 0, void 0, function* () {
        const resultTree = yield testing_2.runSchematic('jest-project', {
            project: 'lib1',
            setupFile: 'angular'
        }, appTree);
        const tsConfig = workspace_1.readJsonInTree(resultTree, 'libs/lib1/tsconfig.spec.json');
        expect(tsConfig).toEqual({
            extends: './tsconfig.json',
            compilerOptions: {
                module: 'commonjs',
                outDir: '../../dist/out-tsc',
                types: ['jest', 'node']
            },
            files: ['src/test-setup.ts'],
            include: ['**/*.spec.ts', '**/*.d.ts']
        });
    }));
    describe('--babelJest', () => {
        it('should have a babel config when true', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                setupFile: 'none',
                babelJest: true
            }, appTree);
            expect(resultTree.exists('/libs/lib1/babel-jest.config.json')).toBeTruthy();
        }));
        it('should NOT have a babel config when false', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                setupFile: 'none',
                babelJest: false
            }, appTree);
            expect(resultTree.exists('/libs/lib1/babel-jest.config.json')).toBeFalsy();
        }));
    });
    describe('--setup-file', () => {
        it('should generate src/test-setup.ts', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                setupFile: 'none'
            }, appTree);
            expect(resultTree.exists('src/test-setup.ts')).toBeFalsy();
        }));
        it('should not list the setup file in workspace.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                setupFile: 'none'
            }, appTree);
            const workspaceJson = workspace_1.readJsonInTree(resultTree, 'workspace.json');
            expect(workspaceJson.projects.lib1.architect.test.options.setupFile).toBeUndefined();
        }));
        it('should not list the setup file in tsconfig.spec.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                setupFile: 'none'
            }, appTree);
            const tsConfig = workspace_1.readJsonInTree(resultTree, 'libs/lib1/tsconfig.spec.json');
            expect(tsConfig.files).toBeUndefined();
        }));
    });
    describe('--skip-setup-file', () => {
        it('should generate src/test-setup.ts', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                skipSetupFile: true
            }, appTree);
            expect(resultTree.exists('src/test-setup.ts')).toBeFalsy();
        }));
        it('should not list the setup file in workspace.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                skipSetupFile: true
            }, appTree);
            const workspaceJson = workspace_1.readJsonInTree(resultTree, 'workspace.json');
            expect(workspaceJson.projects.lib1.architect.test.options.setupFile).toBeUndefined();
        }));
        it('should not list the setup file in tsconfig.spec.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                skipSetupFile: true
            }, appTree);
            const tsConfig = workspace_1.readJsonInTree(resultTree, 'libs/lib1/tsconfig.spec.json');
            expect(tsConfig.files).toBeUndefined();
        }));
    });
    describe('--skip-serializers', () => {
        it('should not list the serializers in jest.config.js', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                skipSerializers: true
            }, appTree);
            const jestConfig = resultTree.readContent('libs/lib1/jest.config.js');
            expect(jestConfig).not.toContain(`
  snapshotSerializers: [
    'jest-preset-angular/build/AngularNoNgAttributesSnapshotSerializer.js,
    'jest-preset-angular/build/AngularSnapshotSerializer.js',
    'jest-preset-angular/build/HTMLCommentSerializer.js'
  ]
`);
        }));
    });
    describe('--support-tsx', () => {
        it('should add tsx to moduleExtensions', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('jest-project', {
                project: 'lib1',
                supportTsx: true
            }, appTree);
            const jestConfig = resultTree.readContent('libs/lib1/jest.config.js');
            expect(jestConfig).toContain(`moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'html'],`);
        }));
    });
});
